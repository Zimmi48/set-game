<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <title>Jeu Set</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f0f0f0;
      padding: 1em;
      text-align: center;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(3, 140px);
      gap: 10px;
      justify-content: center;
    }

    .card {
      background: white;
      border: 2px solid transparent;
      cursor: pointer;
      width: 120px;
      height: 80px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .card.selected {
      border-color: #00f;
    }
  </style>
</head>

<body>
  <h1>Jeu Set</h1>
  <div id="board"></div>
  <p id="message"></p>

  <script>
    const colors = ["red", "green", "purple"];
    const shapes = ["oval", "diamond", "squiggle"];
    const fills = ["solid", "empty", "striped"];
    const numbers = [1, 2, 3];

    // Fill the deck with all combinations of cards
    const deck = [];
    let i = 0;
    for (let c of colors)
      for (let s of shapes)
        for (let f of fills)
          for (let n of numbers)
            deck.push({ color: c, shape: s, fill: f, number: n, id: i++ });

    shuffle(deck);

    let boardCards = deck.splice(0, 12);
    ensureSetAvailable();
    let selectedIndices = [];

    const board = document.getElementById("board");
    const message = document.getElementById("message");

    /**
     * Renders the current board state by creating card elements for each card on the board.
     * Highlights selected cards and attaches click handlers for selection.
     */
    function renderBoard() {
      board.innerHTML = "";
      boardCards.forEach((card, i) => {
        const div = document.createElement("div");
        div.className = "card" + (selectedIndices.includes(i) ? " selected" : "");
        div.innerHTML = getCardSVG(card);
        div.onclick = () => selectCard(i);
        board.appendChild(div);
      });
    }

    /**
     * Handles selection and deselection of cards.
     * When three cards are selected, checks if they form a set.
     * If a set is found, removes or replaces the cards and ensures a set remains available.
     * Displays feedback messages for correct or incorrect sets.
     * @param {number} index - Index of the card to select or deselect.
     */
    function selectCard(index) {
      const i = selectedIndices.indexOf(index);
      if (i >= 0) {
        selectedIndices.splice(i, 1);
      } else {
        if (selectedIndices.length < 3) selectedIndices.push(index);
      }

      renderBoard();

      if (selectedIndices.length === 3) {
        const [a, b, c] = selectedIndices.map(i => boardCards[i]);
        if (isSet(a, b, c)) {
          message.textContent = "✔️ Set trouvé !";
          if (boardCards.length > 12) {
            // Remove the selected cards from the board without replacement
            // We remove the cards in reverse order to avoid index shifting issues
            selectedIndices.sort((a, b) => b - a).forEach(idx => {
              boardCards.splice(idx, 1);
            });
          } else {
            // Replace the selected cards with new ones from the deck
            for (let i = 0; i < 3; i++) {
              const idx = selectedIndices[i];
              boardCards[idx] = deck.length ? deck.pop() : null;
            }
            boardCards = boardCards.filter(Boolean);
          }
          ensureSetAvailable();
        } else {
          message.textContent = "❌ Ce n'est pas un Set.";
        }
        selectedIndices = [];
        setTimeout(() => {
          message.textContent = "";
          renderBoard();
        }, 1000);
      }
    }

    /**
     * Determines if three cards form a valid Set.
     * For each property (color, shape, fill, number), all must be the same or all different.
     * @param {Object} a - First card.
     * @param {Object} b - Second card.
     * @param {Object} c - Third card.
     * @returns {boolean} True if the three cards form a Set, false otherwise.
     */
    function isSet(a, b, c) {
      return ["color", "shape", "fill", "number"].every(prop => {
        const vals = [a[prop], b[prop], c[prop]];
        return new Set(vals).size === 1 || new Set(vals).size === 3;
      });
    }

    /**
     * Generates the SVG markup for a given card, including color, shape, fill, and number.
     * Handles striped fill using SVG patterns.
     * @param {Object} card - Card object with color, shape, fill, number, and id properties.
     * @returns {string} SVG markup as a string.
     */
    function getCardSVG(card) {
      const colorMap = { red: "#d00", green: "#090", purple: "#609" };
      const color = colorMap[card.color];
      const pattern_name = `stripes${card.id}`;
      const fill = card.fill === "solid" ? color :
        card.fill === "empty" ? "none" : `url(#${pattern_name})`;
      const stripeFill = card.fill === "striped" ? 'fill-opacity="0.5"' : "";

      const spacing = 30;
      const startY = 40 - ((card.number - 1) * spacing) / 2;
      const shapes = [];

      for (let i = 0; i < card.number; i++) {
        const y = startY + i * spacing;
        shapes.push(drawShape(card.shape, 60, y, color, fill, stripeFill));
      }

      return `
        <svg viewBox="0 0 120 80">
          <defs>
            <pattern id="${pattern_name}" patternUnits="userSpaceOnUse" width="4" height="4">
              <path d="M0,0 L0,4" stroke="${color}" stroke-width="5" />
            </pattern>
          </defs>
          <g transform="rotate(90 60 40)">
            ${shapes.join("")}
          </g>
        </svg>
      `;
    }

    /**
     * Returns SVG markup for a single shape (oval, diamond, or squiggle) at a given position.
     * @param {string} shape - The shape type ("oval", "diamond", "squiggle").
     * @param {number} x - X coordinate for the shape center.
     * @param {number} y - Y coordinate for the shape center.
     * @param {string} color - Stroke color.
     * @param {string} fill - Fill color or pattern.
     * @param {string} stripeFill - Additional SVG attributes for striped fill.
     * @returns {string} SVG markup for the shape.
     */
    function drawShape(shape, x, y, color, fill, stripeFill) {
      if (shape === "oval") {
        return `<ellipse cx="${x}" cy="${y}" rx="25" ry="12" stroke="${color}" stroke-width="2" fill="${fill}" ${stripeFill} />`;
      } else if (shape === "diamond") {
        return `<polygon points="${x - 25},${y} ${x},${y - 12} ${x + 25},${y} ${x},${y + 12}" stroke="${color}" stroke-width="2" fill="${fill}" ${stripeFill} />`;
      } else if (shape === "squiggle") {
        return `<path d="
          M${x - 30},${y - 10}
          C${x - 10},${y - 30}, ${x + 10},${y + 10}, ${x + 30},${y - 10}
          C${x + 10},${y + 30}, ${x - 10},${y - 10}, ${x - 30},${y + 10}
          Z
        " stroke="${color}" stroke-width="2" fill="${fill}" ${stripeFill} />`;
      }
    }

    /**
     * Shuffles an array in place using the Fisher-Yates algorithm.
     * @param {Array} array - The array to shuffle.
     */
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    /**
     * Checks if there is at least one valid Set among the given cards.
     * @param {Array<Object>} cards - Array of card objects.
     * @returns {boolean} True if a Set exists, false otherwise.
     */
    function hasAvailableSet(cards) {
      for (let i = 0; i < cards.length; i++) {
        for (let j = i + 1; j < cards.length; j++) {
          for (let k = j + 1; k < cards.length; k++) {
            if (isSet(cards[i], cards[j], cards[k])) {
              return true;
            }
          }
        }
      }
      return false;
    }

    /**
     * Ensures that the board always contains at least one valid Set.
     * If not, adds three more cards from the deck (if available) until a Set is present.
     */
    function ensureSetAvailable() {
      while (!hasAvailableSet(boardCards) && deck.length >= 3) {
        boardCards.push(deck.pop());
        boardCards.push(deck.pop());
        boardCards.push(deck.pop());
      }
    }


    renderBoard();
  </script>
</body>

</html>