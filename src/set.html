<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <title>Jeu Set</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: sans-serif;
      background: #f0f0f0;
      padding: 1em;
      text-align: center;
    }

    #board,
    .snapshot {
      display: grid;
      grid-template-columns: repeat(3, 140px);
      gap: 10px;
      justify-content: center;
    }

    .card {
      background: white;
      border: 2px solid transparent;
      cursor: pointer;
      width: 120px;
      height: 80px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .card.selected {
      border-color: #00f;
    }

    .card.faded {
      opacity: 0.1;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    button {
      padding: 0.5em 1.5em;
      font-size: 1em;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 1em;
    }

    @media (max-width: 600px) {

      #board,
      .snapshot {
        grid-template-columns: repeat(3, 28vw);
        gap: 2vw;
        width: 90vw;
        margin: 0 auto;
      }

      .card {
        width: 27vw;
        height: 15vw;
        min-width: 60px;
        min-height: 40px;
        max-width: 90px;
        max-height: 60px;
      }

      /* Responsive styling for set display containers in review sections */
      #snapshots div[style*="display: flex"] {
        flex-wrap: wrap !important;
        justify-content: center !important;
        gap: 1vw !important;
      }

      /* Ensure cards in set display containers are properly sized on mobile */
      #snapshots div[style*="display: flex"] .card {
        width: 27vw !important;
        height: 15vw !important;
        min-width: 60px !important;
        min-height: 40px !important;
        max-width: 90px !important;
        max-height: 60px !important;
      }

      h1 {
        font-size: 1.3em;
      }

      #timer,
      #message {
        font-size: 1em;
      }
    }
  </style>
</head>

<body>
  <h1>Jeu Set</h1>
  <p id="timer">Temps : 0s</p>
  <div id="board"></div>
  <div id="snapshots"></div>
  <p id="message"></p>
  <p id="best-time"></p>
  <button id="restart-btn" style="margin-bottom:1em;">Recommencer</button>

  <script>
    let deck, boardCards, selectedIndices, gameStatus; // { status: "running"|"over", timer: number }
    let boardSnapshots; // Array of { timeSpent, snapshot }
    let missedEasierSets; // Array of { board, selectedSet, easierSets }
    let currentBoardStartTime;
    /**
     * Initializes a new game: creates and shuffles the deck, deals cards, resets state.
     */
    function initializeGame() {
      const colors = ["red", "green", "purple"];
      const shapes = ["oval", "diamond", "squiggle"];
      const fills = ["solid", "empty", "striped"];
      const numbers = [1, 2, 3];

      deck = [];
      let i = 0;
      for (let c of colors)
        for (let s of shapes)
          for (let f of fills)
            for (let n of numbers)
              deck.push({ color: c, shape: s, fill: f, number: n, id: i++ });

      shuffle(deck);

      boardCards = deck.splice(0, 12);
      selectedIndices = [];
      gameStatus = { status: "running", timer: 0 };
      boardSnapshots = [];
      missedEasierSets = [];
      currentBoardStartTime = 0
      ensureSetAvailable();
      saveGameState();
    }

    const board = document.getElementById("board");
    const message = document.getElementById("message");
    const snapshots_div = document.getElementById("snapshots");

    let timerInterval = null;
    let timerPaused = false;
    const timerDisplay = document.getElementById("timer");

    function startTimer() {
      if (timerInterval || gameStatus.status === "over") return;
      timerInterval = setInterval(() => {
        gameStatus.timer++;
        saveGameState();
        timerDisplay.textContent = `Temps : ${formatTime(gameStatus.timer)}`;
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
      timerInterval = null;
    }

    let bestTime = localStorage.getItem("set-best-time") || null;
    const bestTimeDisplay = document.getElementById("best-time");

    /**
     * Updates the best time display if a best time exists.
     */
    function updateBestTimeDisplay() {
      if (bestTime) {
        bestTimeDisplay.textContent = `Meilleur temps : ${formatTime(bestTime)}`;
      } else {
        bestTimeDisplay.textContent = "";
      }
    }

    /* Checks if the current game time is a new best time.
     * If it is, updates the best time in localStorage and displays it.
     * Returns true if a new best time was set, false otherwise.
     */
    function checkAndSaveBestTime() {
      if (!bestTime || gameStatus.timer < bestTime) {
        bestTime = gameStatus.timer;
        localStorage.setItem("set-best-time", bestTime);
        updateBestTimeDisplay();
        return true; // New best time
      }
      return false; // Not a new best time
    }

    function formatTime(seconds) {
      seconds = Number(seconds);
      if (seconds < 60) return `${seconds}s`;
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m}m ${s}s`;
    }

    /**
     * Renders the current board state by creating card elements for each card on the board.
     * Highlights selected cards and attaches click handlers for selection.
     * Optionally fades out non-selected cards.
     * @param {boolean} [faded] - Whether to fade out non-selected cards.
     */
    function renderBoard(faded = false) {
      board.innerHTML = "";
      boardCards.forEach((card, i) => {
        const div = document.createElement("div");
        div.className = "card" +
          (selectedIndices.includes(i) ? " selected" : "") +
          (faded && !selectedIndices.includes(i) ? " faded" : "");
        div.innerHTML = getCardSVG(card);
        div.onclick = () => selectCard(i);
        board.appendChild(div);
      });
    }

    /**
     * Handles selection and deselection of cards.
     * When three cards are selected, checks if they form a set.
     * If a set is found, removes or replaces the cards and ensures a set remains available.
     * Displays feedback messages for correct or incorrect sets.
     * @param {number} index - Index of the card to select or deselect.
     */
    function selectCard(index) {
      if (gameStatus.status === "over") {
        return;
      }
      const i = selectedIndices.indexOf(index);
      if (i >= 0) {
        selectedIndices.splice(i, 1);
      } else {
        if (selectedIndices.length < 3) selectedIndices.push(index);
      }

      if (selectedIndices.length === 3) {
        const [a, b, c] = selectedIndices.map(i => boardCards[i]);
        if (isSet(a, b, c)) {
          message.textContent = "✔️ Set trouvé !";

          // Check for missed easier sets
          const allSets = findAllSets(boardCards);
          const selectedSetDifficulty = getSetDifficulty(a, b, c);
          const easierSets = allSets.filter(set => set.difficulty > selectedSetDifficulty);
          
          if (easierSets.length > 0) {
            // Save the missed easier sets (limit to 3 to avoid memory issues)
            if (missedEasierSets.length < 3) {
              missedEasierSets.push({
                board: boardCards.map(card => ({ ...card })), // Deep copy
                selectedSet: { cards: [a, b, c], difficulty: selectedSetDifficulty },
                easierSets: easierSets.map(set => ({
                  cards: set.cards.map(card => ({ ...card })),
                  difficulty: set.difficulty
                }))
              });
            }
          }

          // Save snapshot of the current board and time spent on the previous board
          const timeSpent = gameStatus.timer - currentBoardStartTime;
          const timeThreshold = Math.min(...boardSnapshots.map(s => s.timeSpent));
          if (timeSpent > timeThreshold || boardSnapshots.length < 3) {
            // Save a deep copy of the boardCards
            boardSnapshots.push({
              timeSpent,
              snapshot: boardCards.map(card => ({ ...card }))
            });
            // Remove a snapshot if we exceed 3
            if (boardSnapshots.length > 3) {
              // Find a snapshot with timeSpent equal to timeThreshold
              const indexToRemove = boardSnapshots.findIndex(s => s.timeSpent === timeThreshold);
              boardSnapshots.splice(indexToRemove, 1);
            }
          }
          currentBoardStartTime = gameStatus.timer;

          // Fade out non-selected cards
          renderBoard(true);
          gameStatus.timer--;
          currentBoardStartTime = gameStatus.timer;

          // Check if this is the last set when the deck is empty
          if (deck.length === 0) {
            // Simulate removal of the selected cards
            let tempBoard = boardCards.slice();
            let indices = selectedIndices.slice().sort((a, b) => b - a);
            indices.forEach(idx => tempBoard.splice(idx, 1));

            // If no sets remain after removal, keep the set on the board and finish the game
            if (!hasAvailableSet(tempBoard)) {
              finishGame();
              saveGameState();
              return; // Do NOT remove the cards, keep final set visible
            }
            // If there are still sets, fall through and remove as usual
          }

          if (boardCards.length > 12) {
            // Remove the selected cards from the board without replacement
            // We remove the cards in reverse order to avoid index shifting issues
            selectedIndices.sort((a, b) => b - a).forEach(idx => {
              boardCards.splice(idx, 1);
            });
          } else {
            // Replace the selected cards with new ones from the deck
            for (let i = 0; i < 3; i++) {
              const idx = selectedIndices[i];
              boardCards[idx] = deck.length ? deck.pop() : null;
            }
            boardCards = boardCards.filter(Boolean);
          }
          ensureSetAvailable();
          saveGameState();
        } else {
          message.textContent = "❌ Ce n'est pas un Set.";
          renderBoard();
          setTimeout(() => {
            displayCardsLeft();
            renderBoard();
          }, 1000);
        }
        selectedIndices = [];
      }
      else {
        renderBoard();
      }
    }

    /**
     * Finishes the game by checking if the current time is a new best time,
     * displaying a message, and stopping the timer.
     */
    function finishGame() {
      gameStatus.timer++; // Cancel the decrement from above
      let newBestTime = checkAndSaveBestTime();
      if (newBestTime) {
        message.textContent = `🚀 Nouveau meilleur temps : ${formatTime(gameStatus.timer)} !`;
      } else {
        message.textContent = `🎉 Partie terminée en ${formatTime(gameStatus.timer)} !`;
      }
      gameStatus.status = "over";
      stopTimer();

      showReviewButton();
    }

    reviewBtn = null;
    missedEasierBtn = null;

    /**
     * Displays buttons to review the hardest boards and missed easier sets.
     * These buttons are shown when the game is over.
     */
    function showReviewButton() {
      // Only create review button if it doesn't already exist
      if (reviewBtn) return;
      
      // Create the review button for hardest boards
      reviewBtn = document.createElement("button");
      reviewBtn.textContent = "Voir les plateaux les plus difficiles";
      reviewBtn.style.marginLeft = "1em";
      reviewBtn.onclick = () => {
        showHardestBoards();
        reviewBtn.remove();
        reviewBtn = null;
        if (missedEasierBtn) {
          missedEasierBtn.remove();
          missedEasierBtn = null;
        }
      };
      document.body.appendChild(reviewBtn);
      
      // Create the missed easier sets button if there are any
      if (missedEasierSets.length > 0) {
        missedEasierBtn = document.createElement("button");
        missedEasierBtn.textContent = "Voir les Sets plus faciles manqués";
        missedEasierBtn.style.marginLeft = "1em";
        missedEasierBtn.onclick = () => {
          showMissedEasierSets();
          missedEasierBtn.remove();
          missedEasierBtn = null;
          if (reviewBtn) {
            reviewBtn.remove();
            reviewBtn = null;
          }
        };
        document.body.appendChild(missedEasierBtn);
      }
    }

    /**
     * Determines if three cards form a valid Set.
     * For each property (color, shape, fill, number), all must be the same or all different.
     * @param {Object} a - First card.
     * @param {Object} b - Second card.
     * @param {Object} c - Third card.
     * @returns {boolean} True if the three cards form a Set, false otherwise.
     */
    function isSet(a, b, c) {
      return ["color", "shape", "fill", "number"].every(prop => {
        const vals = [a[prop], b[prop], c[prop]];
        return new Set(vals).size === 1 || new Set(vals).size === 3;
      });
    }

    /**
     * Calculates the difficulty of a set based on the number of fixed characteristics.
     * A set is easier (higher difficulty score) if it has more characteristics that are the same.
     * @param {Object} a - First card.
     * @param {Object} b - Second card.
     * @param {Object} c - Third card.
     * @returns {number} Number of fixed characteristics (0-4, where 4 is easiest).
     */
    function getSetDifficulty(a, b, c) {
      let fixedCharacteristics = 0;
      ["color", "shape", "fill", "number"].forEach(prop => {
        const vals = [a[prop], b[prop], c[prop]];
        if (new Set(vals).size === 1) {
          fixedCharacteristics++;
        }
      });
      return fixedCharacteristics;
    }

    /**
     * Finds all available sets on the current board.
     * @param {Array<Object>} cards - Array of card objects.
     * @returns {Array<Object>} Array of set objects with cards, indices, and difficulty.
     */
    function findAllSets(cards) {
      const sets = [];
      for (let i = 0; i < cards.length; i++) {
        for (let j = i + 1; j < cards.length; j++) {
          for (let k = j + 1; k < cards.length; k++) {
            if (isSet(cards[i], cards[j], cards[k])) {
              const difficulty = getSetDifficulty(cards[i], cards[j], cards[k]);
              sets.push({
                cards: [cards[i], cards[j], cards[k]],
                indices: [i, j, k],
                difficulty: difficulty
              });
            }
          }
        }
      }
      return sets;
    }

    /**
     * Generates the SVG markup for a given card, including color, shape, fill, and number.
     * Handles striped fill using SVG patterns.
     * @param {Object} card - Card object with color, shape, fill, number, and id properties.
     * @returns {string} SVG markup as a string.
     */
    function getCardSVG(card) {
      const colorMap = { red: "#d00", green: "#090", purple: "#609" };
      const color = colorMap[card.color];
      const pattern_name = `stripes${card.id}`;
      const fill = card.fill === "solid" ? color :
        card.fill === "empty" ? "none" : `url(#${pattern_name})`;
      const stripeFill = card.fill === "striped" ? 'fill-opacity="0.5"' : "";

      const spacing = 30;
      const startY = 40 - ((card.number - 1) * spacing) / 2;
      const shapes = [];

      for (let i = 0; i < card.number; i++) {
        const y = startY + i * spacing;
        shapes.push(drawShape(card.shape, 60, y, color, fill, stripeFill));
      }

      return `
        <svg viewBox="0 0 120 80">
          <defs>
            <pattern id="${pattern_name}" patternUnits="userSpaceOnUse" width="4" height="4">
              <path d="M0,0 L0,4" stroke="${color}" stroke-width="5" />
            </pattern>
          </defs>
          <g transform="rotate(90 60 40)">
            ${shapes.join("")}
          </g>
        </svg>
      `;
    }

    /**
     * Returns SVG markup for a single shape (oval, diamond, or squiggle) at a given position.
     * @param {string} shape - The shape type ("oval", "diamond", "squiggle").
     * @param {number} x - X coordinate for the shape center.
     * @param {number} y - Y coordinate for the shape center.
     * @param {string} color - Stroke color.
     * @param {string} fill - Fill color or pattern.
     * @param {string} stripeFill - Additional SVG attributes for striped fill.
     * @returns {string} SVG markup for the shape.
     */
    function drawShape(shape, x, y, color, fill, stripeFill) {
      if (shape === "oval") {
        return `<ellipse cx="${x}" cy="${y}" rx="25" ry="12" stroke="${color}" stroke-width="2" fill="${fill}" ${stripeFill} />`;
      } else if (shape === "diamond") {
        return `<polygon points="${x - 25},${y} ${x},${y - 12} ${x + 25},${y} ${x},${y + 12}" stroke="${color}" stroke-width="2" fill="${fill}" ${stripeFill} />`;
      } else if (shape === "squiggle") {
        return `<path d="
          M${x - 30},${y - 10}
          C${x - 10},${y - 30}, ${x + 10},${y + 10}, ${x + 30},${y - 10}
          C${x + 10},${y + 30}, ${x - 10},${y - 10}, ${x - 30},${y + 10}
          Z
        " stroke="${color}" stroke-width="2" fill="${fill}" ${stripeFill} />`;
      }
    }

    /**
     * Displays the number of cards left in the deck.
     * Updates the message element with the count.
     */
    function displayCardsLeft() {
      message.textContent = "Nombre de cartes dans la pioche : " + deck.length;
    }

    /**
     * Shuffles an array in place using the Fisher-Yates algorithm.
     * @param {Array} array - The array to shuffle.
     */
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    /**
     * Checks if there is at least one valid Set among the given cards.
     * @param {Array<Object>} cards - Array of card objects.
     * @returns {boolean} True if a Set exists, false otherwise.
     */
    function hasAvailableSet(cards) {
      for (let i = 0; i < cards.length; i++) {
        for (let j = i + 1; j < cards.length; j++) {
          for (let k = j + 1; k < cards.length; k++) {
            if (isSet(cards[i], cards[j], cards[k])) {
              return true;
            }
          }
        }
      }
      return false;
    }

    /**
     * Ensures that the board always contains at least one valid Set.
     * If not, adds three more cards from the deck (if available) until a Set is present.
     */
    function ensureSetAvailable() {
      while (!hasAvailableSet(boardCards) && deck.length >= 3) {
        boardCards.push(deck.pop());
        boardCards.push(deck.pop());
        boardCards.push(deck.pop());
      }
      if (!hasAvailableSet(boardCards)) {
        finishGame();
      } else {
        setTimeout(() => {
          displayCardsLeft();
          renderBoard();
          saveGameState();
        }, 1000);
      }
    }

    // Prevent screen from dimming/locking on mobile
    if ('wakeLock' in navigator) {
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (err) {
          // Wake Lock request failed - ignore or handle error
        }
      }
      requestWakeLock();
      // Re-request on visibility change (e.g., after tab switch)
      document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') {
          requestWakeLock();
        }
      });
    }

    function saveGameState() {
      const state = {
        deck,
        boardCards,
        selectedIndices,
        gameStatus,
        message: message.textContent,
        boardSnapshots,
        missedEasierSets,
        currentBoardStartTime,
      };
      localStorage.setItem("setGameState", JSON.stringify(state));
    }

    function clearGameState() {
      localStorage.removeItem("setGameState");
    }

    /**
     * Displays the three hardest boards based on time spent finding a Set.
     * Each board snapshot is displayed with its time spent and the cards.
     */
    function showHardestBoards() {
      board.innerHTML = "";
      // Create and insert the intro sentence above the boards
      const intro = document.createElement("div");
      intro.textContent = "Voici les 3 plateaux pour lesquels vous avez mis le plus de temps à trouver un Set :";
      intro.style.margin = "1em 0";
      snapshots_div.append(intro);

      boardSnapshots.sort((a, b) => b.timeSpent - a.timeSpent).forEach((snap, idx) => {
        const miniBoard = document.createElement("div");
        miniBoard.className = "snapshot";

        const title = document.createElement("div");
        title.innerHTML = `<p><strong>Plateau #${idx + 1} (${formatTime(snap.timeSpent)})</strong></p>`;
        title.style.marginBottom = "0.5em";

        snap.snapshot.forEach(card => {
          const cardDiv = document.createElement("div");
          cardDiv.className = "card";
          cardDiv.innerHTML = getCardSVG(card);
          miniBoard.appendChild(cardDiv);
        });
        snapshots_div.append(title, miniBoard);
      });
    }

    /**
     * Displays boards where easier sets were missed.
     * Shows the board, the set the player chose, and the easier sets that were available.
     */
    function showMissedEasierSets() {
      board.innerHTML = "";
      // Create and insert the intro sentence above the boards
      const intro = document.createElement("div");
      intro.textContent = "Voici les plateaux où vous avez manqué des Sets plus faciles :";
      intro.style.margin = "1em 0";
      snapshots_div.append(intro);

      missedEasierSets.forEach((missed, idx) => {
        const section = document.createElement("div");
        section.style.margin = "2em 0";
        section.style.padding = "1em";
        section.style.border = "1px solid #ccc";
        section.style.borderRadius = "8px";
        
        const title = document.createElement("div");
        title.innerHTML = `<p><strong>Plateau #${idx + 1}</strong></p>`;
        title.style.marginBottom = "1em";
        
        // Show the board
        const boardDiv = document.createElement("div");
        boardDiv.className = "snapshot";
        boardDiv.style.marginBottom = "1em";
        
        missed.board.forEach(card => {
          const cardDiv = document.createElement("div");
          cardDiv.className = "card";
          cardDiv.innerHTML = getCardSVG(card);
          boardDiv.appendChild(cardDiv);
        });
        
        // Show selected set
        const selectedInfo = document.createElement("div");
        selectedInfo.innerHTML = `<p><strong>Set choisi (${missed.selectedSet.difficulty} caractéristique${missed.selectedSet.difficulty > 1 ? 's' : ''} fixe${missed.selectedSet.difficulty > 1 ? 's' : ''}) :</strong></p>`;
        selectedInfo.style.margin = "1em 0";
        
        const selectedSetDiv = document.createElement("div");
        selectedSetDiv.style.display = "flex";
        selectedSetDiv.style.gap = "10px";
        selectedSetDiv.style.justifyContent = "center";
        selectedSetDiv.style.marginBottom = "1em";
        
        missed.selectedSet.cards.forEach(card => {
          const cardDiv = document.createElement("div");
          cardDiv.className = "card";
          cardDiv.style.border = "3px solid #ff0000";
          cardDiv.innerHTML = getCardSVG(card);
          selectedSetDiv.appendChild(cardDiv);
        });
        
        // Show easier sets that were available
        const easierInfo = document.createElement("div");
        const maxDifficulty = Math.max(...missed.easierSets.map(s => s.difficulty));
        easierInfo.innerHTML = `<p><strong>Set${missed.easierSets.length > 1 ? 's' : ''} plus facile${missed.easierSets.length > 1 ? 's' : ''} disponible${missed.easierSets.length > 1 ? 's' : ''} (${maxDifficulty} caractéristique${maxDifficulty > 1 ? 's' : ''} fixe${maxDifficulty > 1 ? 's' : ''}) :</strong></p>`;
        easierInfo.style.margin = "1em 0";
        
        // Show the easiest set that was available
        const easiestSet = missed.easierSets.find(s => s.difficulty === maxDifficulty);
        const easierSetDiv = document.createElement("div");
        easierSetDiv.style.display = "flex";
        easierSetDiv.style.gap = "10px";
        easierSetDiv.style.justifyContent = "center";
        
        easiestSet.cards.forEach(card => {
          const cardDiv = document.createElement("div");
          cardDiv.className = "card";
          cardDiv.style.border = "3px solid #00ff00";
          cardDiv.innerHTML = getCardSVG(card);
          easierSetDiv.appendChild(cardDiv);
        });
        
        section.append(title, boardDiv, selectedInfo, selectedSetDiv, easierInfo, easierSetDiv);
        snapshots_div.append(section);
      });
    }

    // Setup restart button handler
    const restartBtn = document.getElementById("restart-btn");
    restartBtn.onclick = () => {
      stopTimer();
      clearGameState();
      initializeGame();
      updateBestTimeDisplay();
      renderBoard();
      displayCardsLeft();
      startTimer();
      message.textContent = "";
      snapshots_div.innerHTML = ""; // Clear previous snapshots
      if (reviewBtn) {
        reviewBtn.remove(); // Remove review button if it exists
        reviewBtn = null;
      }
      if (missedEasierBtn) {
        missedEasierBtn.remove(); // Remove missed easier sets button if it exists
        missedEasierBtn = null;
      }
    };

    // --- Initialization ---
    const saved = localStorage.getItem("setGameState");
    if (saved) {
      const state = JSON.parse(saved);
      // Validate saved state structure
      if (!state.deck || !Array.isArray(state.deck) ||
        !state.boardCards || !Array.isArray(state.boardCards) ||
        !state.selectedIndices || !Array.isArray(state.selectedIndices) ||
        !state.gameStatus || typeof state.gameStatus !== 'object' ||
        typeof state.gameStatus.status !== 'string' ||
        (state.gameStatus.status !== "running" && state.gameStatus.status !== "over") ||
        typeof state.gameStatus.timer !== 'number' ||
        (state.gameStatus.status === "over" && typeof state.message !== 'string')) {
        console.error("Invalid saved game state, starting a new game.");
        initializeGame();
      } else {
        // Load saved state
        deck = state.deck;
        boardCards = state.boardCards;
        selectedIndices = state.selectedIndices;
        gameStatus = state.gameStatus;
        boardSnapshots = state.boardSnapshots || [];
        missedEasierSets = state.missedEasierSets || [];
        currentBoardStartTime = state.currentBoardStartTime || null;
        if (gameStatus.status === "over" && state.message) {
          message.textContent = state.message;
          showReviewButton();
        }
      }
    } else {
      initializeGame();
    }

    updateBestTimeDisplay();

    if (gameStatus.status === "running") {
      displayCardsLeft();
      renderBoard();
      startTimer();
    }
    else {
      renderBoard(true); // Show final set
      timerDisplay.textContent = `Temps : ${formatTime(gameStatus.timer)}`;
    }

  </script>
</body>

</html>